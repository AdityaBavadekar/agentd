"""The master agent for the agentd system."""

# if new agents are added/removed,
# just use this from project dir: `cd agentd/subagents && for a in $(ls); do echo "from .sub_agents.${a} import ${a}"; done;`
# to generate the import statements


from google.adk.agents import Agent, ParallelAgent, SequentialAgent
from google.adk.agents.callback_context import CallbackContext

from agentd.utils import create_and_upload_pdf, extract_json_from_text, json_to_markdown

from . import agent_constants
from .sub_agents.architecture_agent import architecture_agent
from .sub_agents.competitor_analysis_agent import competitor_analysis_agent
from .sub_agents.idea_value_identifier_agent import idea_value_identifier_agent
from .sub_agents.problem_identification_agent import problem_identification_agent
from .sub_agents.report_generation_agent import report_generation_agent
from .sub_agents.social_media_post_generation_agent import (
    social_media_post_generation_agent,
)
from .sub_agents.solution_analysis_agent import solution_analysis_agent
from .sub_agents.target_users_analysis_agent import target_users_analysis_agent
from .sub_agents.technical_advisor_agent import technical_advisor_agent
from .sub_agents.topic_analysis_agent import topic_analysis_agent

"""
Agents involved in the system:

Root Agent:

    Topic Analysis Pipeline (SEQUENTIAL)
        - Topic Analysis Agent
        - Problem Identification Agent << [google_search]
        - Solution Analysis Agent
        - [User Input] << User selects a problem statement and solution from the identified problems

    Solution Analysis Pipeline (SEQUENTIAL)
        - Target Users Analysis Agent << [google_search]
        - Competitor Analysis Agent << [google_search]
        - Report Generation Agent  << [image_generation_agent_tool] => Save Report and Images to Cloud Storage
        - [User Input] << User is answers whether he would like to proceed with a detailed report

    Detailing Pipeline (PARELLEL)
        - Idea Value Identifier Agent
        - Technical Advisor Agent
        - Architecture Agent << [google_search]
        
    Social Media Post Generation Agent (If user requests) << [image_generation_agent_tool (<< [generate_image])]
    
    Finalization Pipeline (Simple Agent)
"""

topic_analysis_pipeline = SequentialAgent(
    name="TOPIC_ANALYSIS_PIPELINE",
    description="A pipeline for analyzing topics related to a given idea.",
    sub_agents=[
        topic_analysis_agent,
        problem_identification_agent,
        solution_analysis_agent,  # sets state user input required to True
    ],
)

phase_2_pipeline = SequentialAgent(
    name="SOLUTION_ANALYSIS_PIPELINE",
    description="A pipeline for analyzing the selected solution and generating a complete report.",
    sub_agents=[
        target_users_analysis_agent,
        competitor_analysis_agent,
        report_generation_agent,
    ],
)

# all of these will run in parallel
phase_3_pipeline = ParallelAgent(
    name="DETAILING_PIPELINE",
    description="A pipeline for provide detailed aspects of the solution.",
    sub_agents=[
        idea_value_identifier_agent,
        SequentialAgent(
            name="TECHNICAL_PIPELINE",
            sub_agents=[
                technical_advisor_agent,
                architecture_agent,
            ],
        ),
    ],
)


def simple_after_model_modifier(callback_context: CallbackContext, *_args, **_kwargs):
    # combine the outputs of agents into a full report
    # check if the architecture agent has run since it is the last agent in the pipeline
    if architecture_agent.output_key not in callback_context.state:
        return None

    print("===" * 8)
    print("== GENERATING MASTER REPORT ==")
    print("===" * 8)

    selected_keys = [
        # topic_analysis_agent.output_key,
        # problem_identification_agent.output_key,
        solution_analysis_agent.output_key,
        target_users_analysis_agent.output_key,
        competitor_analysis_agent.output_key,
        report_generation_agent.output_key,
        idea_value_identifier_agent.output_key,
        technical_advisor_agent.output_key,
        architecture_agent.output_key,
        social_media_post_generation_agent.output_key,
    ]

    # collect all values for the keys from the state
    final_markdown = "# Master Report\n\n"
    final_markdown += "This report is generated by the AgentD system.\n\n"

    for key in selected_keys:
        if key in callback_context.state:
            value = callback_context.state[key]

            # value could be a json string dump
            try:
                final_markdown += f"## {key.replace('_', ' ').title()}\n\n"
                json_data = extract_json_from_text(value)
                if json_data:
                    value = json_data
            except Exception as e:
                print(f"Error extracting JSON from {key}: {e}")

            final_markdown += "\n\n"
            if isinstance(value, dict) or isinstance(value, list):
                final_markdown += json_to_markdown(value)
            else:
                final_markdown += "\n\n"
                final_markdown += f"{value}\n\n"

            final_markdown += "---\n\n"

    public_url = create_and_upload_pdf(
        markdown_content=final_markdown,
        pdf_title="Master Report",
        local_dir="master_reports",
        remote_dir="master_reports",
    )
    callback_context.state["master_report_url"] = public_url
    print(f"Master report generated and uploaded to: {public_url}")
    print("===" * 8)

    return types.Content(
        parts=[
            types.Part(
                text=f"\n\n## Download Report:\nYou can download the Master report from [here]({public_url}).",
            ),
            types.Part(
                text="<ASK>Please do tell if you would also like to generate social media posts for your Idea.<ASK>",
            ),
        ],
        role="model",
    )
    return None


root_agent = Agent(
    name=agent_constants.AGENT_NAME,
    model=agent_constants.MODEL,
    instruction=agent_constants.AGENT_INSTRUCTION,
    description=agent_constants.AGENT_DESCRIPTION,
    after_agent_callback=simple_after_model_modifier,
    sub_agents=[
        topic_analysis_pipeline,
        # take the user input,
        phase_2_pipeline,
        phase_3_pipeline,
        social_media_post_generation_agent,  # this will run only if the user specifically asks for it
    ],
)


def run_preliminary_tests():
    print("=========================================================")

    # - Check if all python packages are installed
    print(
        "[PRELIMINARY CHECK] Checking if all required Python packages are installed..."
    )
    try:
        # pylint: disable=unused-import
        import google.adk
        import google.cloud.storage
        import graphviz
        import markdown2
        import matplotlib.pyplot as plt
        import requests
        import weasyprint
        from wordcloud import WordCloud
    except ImportError as e:
        print(
            f"[PRELIMINARY CHECK: FAILED!] Missing required package: {e.name}. Please install it using pip."
        )
        return

    # - Check working of Cloud Storage
    from agentd.utils import get_cloud_storage

    # this will throw an error if the environment variables are missing or authentication fails
    print("[PRELIMINARY CHECK] Testing Cloud Storage...")
    get_cloud_storage()
    print("[PRELIMINARY CHECK] Cloud Storage is working correctly.")

    print("[PRELIMINARY CHECK] All preliminary checks passed.")
    print("=========================================================")


"""The class for the agentd api."""

from datetime import datetime

from google.adk.events import Event
from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService, Session
from google.genai import types

from .agent import root_agent


class AgentD:

    class EventType:
        """Enum for event types in AgentD."""

        TOOL_CALL_REQUEST = "tool_call_request"
        TOOL_RESULT = "tool_result"
        TEXT_MESSAGE = "text_message"
        CONTROL_SIGNAL = "control_signal"
        USER_INPUT_REQUEST = "user_input_request"
        PROGRESS_UPDATE = "progress_update"
        FILE_URL = "file_url"

    def parse_tool_call_event(self, event: Event):
        """Parse a tool call event and return its details."""
        tool_calls = []
        for call in event.get_function_calls():
            tool_calls.append(
                {
                    "name": call.name,
                    "args": call.args,
                }
            )

        return tool_calls

    def parse_tool_result_event(self, event: Event):
        """Parse a tool result event and return its details."""
        tool_results = []
        for resp in event.get_function_responses():
            tool_results.append(
                {
                    "name": resp.name,
                    "response": resp.response,
                }
            )

        return tool_results

    def __init__(self):
        self.log("INITIALIZING AGENTD")
        self._setup()
        self.log("AGENTD INITIALIZED")

    def _setup(self):
        session_service = InMemorySessionService()
        runner = Runner(
            agent=root_agent,
            session_service=session_service,
            app_name="agentd",
        )
        self.runner = runner
        self.session_service = session_service

    def log(self, message: str):
        print(f"========= [AGENTD] {message} =========")

    @staticmethod
    def generate_user_id() -> str:
        """Generate a unique user ID based on the current timestamp."""
        import uuid

        return "u_" + str(uuid.uuid4())

    async def new_sesion(self, user_id: str = None):
        self.log(f"CREATING NEW SESSION FOR 'user:{user_id}'")
        session = await self.session_service.create_session(
            session_id=str(datetime.now().timestamp()),
            app_name="agentd",
            user_id=user_id,
        )
        self.log(f"SESSION CREATED: {session.id} for user: {user_id}")
        return session

    @staticmethod
    def get_progress_from_agent(agent_name: str) -> int:
        """
        Returns the progress percentage based on the agent_name.
        """
        agent_progress_map = {
            "topic_analysis_agent": 5,
            "problem_identification_agent": 15,
            "solution_analysis_agent": 30,
            "target_users_analysis_agent": 40,
            "competitor_analysis_agent": 50,
            "report_generation_agent": 70,
            "idea_value_identifier_agent": 80,
            "technical_advisor_agent": 90,
            "architecture_agent": 100,
        }

        return agent_progress_map.get(agent_name, 100)

    async def continue_session(
        self,
        message: str,
        session: Session = None,
        session_id: str = None,
        callback=None,
    ):
        if not session:
            if not session_id:
                raise ValueError("Either session or session_id must be provided.")
            session = await self.session_service.get_session(session_id)
            if not session:
                raise ValueError(f"Session with ID {session_id} does not exist.")

        self.log(f"CONTINUING SESSION '{session.id}'")

        await self.run(
            session,
            new_message=types.Content(role="user", parts=[types.Part(text=message)]),
            callback=callback,
        )

    async def run(
        self, session: Session, new_message: types.Content = None, callback=None
    ):
        self.log(f"RUNNING AGENTD FOR SESSION '{session.id}'")

        from google.genai import errors

        try:
            async for event in self.runner.run_async(
                user_id=session.user_id, session_id=session.id, new_message=new_message
            ):
                event: Event
                print(f"@({event.author})")

                if event.content and event.content.parts:
                    if event.get_function_calls():
                        if callback:
                            callback(event, AgentD.EventType.TOOL_CALL_REQUEST)
                        print("  • Type: Tool Call Request")
                        for call in event.get_function_calls():
                            print(f"    ↳ Function: {call.name}")
                            print(f"    ↳ Args: {call.args}")
                    elif event.get_function_responses():
                        if callback:
                            callback(event, AgentD.EventType.TOOL_RESULT)
                        print("  • Type: Tool Result")
                        for resp in event.get_function_responses():
                            print(f"    ↳ Function: {resp.name}")
                            print(f"    ↳ Result: {resp.response}")
                    elif event.content.parts[0].text:
                        text = event.content.parts[0].text.strip()
                        if callback:
                            if ("<ASK>") in text:
                                # this is a user input request
                                prompt = (
                                    text.replace("<ASK>", "")
                                    .replace("</ASK>", "")
                                    .strip()
                                )
                                print("  • Type: User Input Request")
                                print(f"    ↳ Prompt: {prompt}")
                                callback(
                                    {"agent_name": event.author, "description": prompt},
                                    AgentD.EventType.USER_INPUT_REQUEST,
                                )
                            else:
                                texts = [t.text.strip() for t in event.content.parts]
                                callback(texts, AgentD.EventType.TEXT_MESSAGE)
                                # calc progress based on agent name
                                agent_name = event.author
                                progress = AgentD.get_progress_from_agent(agent_name)
                                callback(
                                    progress,
                                    AgentD.EventType.PROGRESS_UPDATE,
                                )

                        if event.partial:
                            print("  • Type: Streaming Text Chunk")
                        else:
                            print("  • Type: Complete Text Message")
                        print(f"    ↳ Text: {text}")
                    else:
                        print("  • Type: Other Content (e.g., code result)")
                elif event.actions and (
                    event.actions.state_delta or event.actions.artifact_delta
                ):
                    print("  • Type: State/Artifact Update")
                    if event.actions.state_delta:
                        print(f"    ↳ State Delta: {event.actions.state_delta}")
                        print("    ↳ Updated State:")
                        for key, value in event.actions.state_delta.items():
                            print(f"      - {key}: {value}")

                        if "user_input_specs" in event.actions.state_delta:
                            user_input_specs = event.actions.state_delta[
                                "user_input_specs"
                            ]
                            if user_input_specs and user_input_specs.get(
                                "required", False
                            ):
                                if callback:
                                    callback(
                                        user_input_specs,
                                        AgentD.EventType.USER_INPUT_REQUEST,
                                    )

                    if event.actions.artifact_delta:
                        print(f"    ↳ Artifact Delta: {event.actions.artifact_delta}")
                else:
                    print("  • Type: Control Signal or Other")
                    if callback:
                        callback(event, AgentD.EventType.CONTROL_SIGNAL)

        except errors.APIError as e:
            import json

            d = e.details
            print(f"[ERROR] APIError: {json.dumps(d, indent=2)}")
        except Exception as e:
            print(f"An error occurred while running AgentD: {e}")
            if callback:
                callback(e, AgentD.EventType.CONTROL_SIGNAL)

        if "master_report_url" in session.state:
            master_report_url = session.state["master_report_url"]
            if callback:
                callback(
                    {
                        "url": master_report_url,
                        "description": "Master report generated by AgentD.",
                        "name": "Master Report",
                        "filetype": "pdf",
                    },
                    AgentD.EventType.FILE_URL,
                )

        # check is user input is required
        if session.state.get("user_input_specs") and session.state[
            "user_input_specs"
        ].get("required", False):
            user_input_specs = session.state["user_input_specs"]
            agent_asking = session.state.get("agent_name", "Unknown Agent")
            if callback:
                callback(user_input_specs, AgentD.EventType.USER_INPUT_REQUEST)

            prompt_for_user = user_input_specs.get(
                "description", "Please provide your input."
            )
            print("  • User Input Required:")
            print(
                f"    ↳ Specs: '{agent_asking}' is asking for input: {prompt_for_user}"
            )
            # since state is consumed, we can remove it
            session.state.pop("user_input_specs")
